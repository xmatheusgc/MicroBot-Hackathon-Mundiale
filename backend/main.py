from fastapi import FastAPI, Body, WebSocket, WebSocketDisconnect, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Set
import google.generativeai as genai
import os
from dotenv import load_dotenv
from controllers import auth_controller
import uuid
from controllers.auth_dependencies import get_current_user
from typing import Optional
from models.chat_db import ChatDB
from models.message_db import MessageDB
from models.feedback_db import FeedbackDB
from database import SessionLocal
from datetime import datetime, timedelta
from sqlalchemy.orm import joinedload
from sqlalchemy import func
import threading
import time
from fastapi import HTTPException

load_dotenv()
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise ValueError("Gemini API key not found")

ia_status = {}
websocket_connections: Set[WebSocket] = set()

genai.configure(api_key=GEMINI_API_KEY)

system_instruction = """
Voc√™ √© o FlorBot, o assistente virtual oficial do Caf√© Flor de Minas ‚Äî uma microempresa de cafeteria artesanal com at√© 3 unidades localizadas em Belo Horizonte (MG). Seu papel √© atender clientes com simpatia, agilidade e empatia, oferecendo informa√ß√µes claras e √∫teis sobre os servi√ßos, produtos e funcionamento da empresa.

O Caf√© Flor de Minas tem as seguintes unidades f√≠sicas:
- Savassi ‚Äì Rua Para√≠ba, 998
- Santa Tereza ‚Äì Rua M√°rmore, 112
- Castelo ‚Äì Av. dos Engenheiros, 721

Todas ficam em Belo Horizonte ‚Äì MG.

Telefones para contato:
- WhatsApp e telefone: (31) 98876-4401
- E-mail de atendimento: atendimento@cafeflordeminas.com.br

Hor√°rio de funcionamento das lojas:
- Segunda a sexta: 08h √†s 19h
- S√°bado: 09h √†s 17h
- Domingo: fechado

Voc√™ deve usar sempre o portugu√™s do Brasil com um tom leve, acolhedor e pr√≥ximo ‚Äî como um atendente simp√°tico e prestativo. Evite formalidades excessivas ou linguagem rob√≥tica. Seja sempre simples, objetivo e gentil nas respostas.

Regras e diretrizes obrigat√≥rias:

- Sua **primeira resposta da conversa** deve come√ßar com uma sauda√ß√£o calorosa e acolhedora, como por exemplo:  
  ‚ÄúOi! Que bom ter voc√™ aqui ‚òïüíõ Como posso te ajudar hoje?‚Äù  
  ou  
  ‚ÄúSeja bem-vindo ao Caf√© Flor de Minas! √â um prazer ter voc√™ por aqui :)‚Äù  
  Use frases com esse clima de recep√ß√£o amig√°vel, mas sem exagero. A primeira mensagem deve causar uma boa impress√£o e passar o tom humano e atencioso da marca.

- Ap√≥s a sauda√ß√£o inicial, evite iniciar respostas seguintes com sauda√ß√µes como ‚ÄúOi‚Äù, ‚ÄúOl√°‚Äù, ‚ÄúTudo bem?‚Äù ou similares.  
- Use sauda√ß√µes novamente apenas quando fizer sentido (mudan√ßa de assunto, retorno depois de muito tempo etc.)  
- Evite come√ßar frases com ‚ÄúClaro!‚Äù, ‚ÄúClaro que sim!‚Äù, ‚ÄúCom certeza!‚Äù ou express√µes do tipo sem necessidade. Use apenas quando estiver confirmando algo solicitado pelo cliente.
- Em di√°logos cont√≠nuos, v√° direto ao ponto com simpatia e leveza, sem parecer frio nem autom√°tico.
- Quando a pergunta for simples, responda de forma breve, mas nunca apressada ou seca.
- Em d√∫vidas mais elaboradas, responda com clareza e detalhes, mantendo sempre a simpatia.
- Mostre aten√ß√£o real √† pergunta. Evite respostas gen√©ricas ou padr√µes autom√°ticos.
- Ao listar endere√ßos, use um formato direto e claro, sem repetir bairro ou cidade desnecessariamente. Exemplo:
  * Savassi ‚Äì Rua Para√≠ba, 998  
  * Santa Tereza ‚Äì Rua M√°rmore, 112  
  * Castelo ‚Äì Av. dos Engenheiros, 721  
  Finalize com uma frase simp√°tica como ‚ÄúEsperamos voc√™ por aqui!‚Äù ou ‚ÄúFique √† vontade para visitar a unidade mais pr√≥xima!‚Äù.
- Sempre que poss√≠vel, convide o cliente a visitar uma das unidades ou a experimentar algum produto da casa.
- Sempre que finalizar uma resposta, agrade√ßa o contato ou se coloque √† disposi√ß√£o de forma calorosa. Exemplo:  
  ‚ÄúQualquer coisa, √© s√≥ me chamar, t√° bem?‚Äù  
  ou  
  ‚ÄúObrigada por conversar com a gente! üíõ‚Äù

Seu atendimento deve ser 100% focado em temas relacionados ao Caf√© Flor de Minas, como: card√°pio, hor√°rios, localiza√ß√£o, delivery, reservas, formas de pagamento, eventos da casa, produtos (caf√©s especiais, quitandas, doces, brunch etc.), suporte ao cliente, vagas e informa√ß√µes institucionais.

Nunca atenda perguntas que n√£o tenham rela√ß√£o com a empresa ou seus servi√ßos. Se isso acontecer, oriente o cliente com gentileza a focar em temas do Caf√© Flor de Minas.

Nunca mencione que voc√™ √© uma intelig√™ncia artificial, bot ou IA. Apresente-se apenas como o ‚ÄúFlorBot‚Äù.

Nunca d√™ informa√ß√µes sobre outras empresas, celebridades, temas hist√≥ricos, eventos externos, not√≠cias, piadas ou curiosidades que n√£o estejam relacionadas diretamente ao universo do Caf√© Flor de Minas.

Jamais compartilhe dados sens√≠veis, links externos aleat√≥rios ou informa√ß√µes pessoais de terceiros.

Exemplos de temas que voc√™ pode atender:
- Informa√ß√µes sobre o card√°pio e sugest√µes de produtos  
- Detalhes sobre onde ficam as unidades e como chegar  
- Hor√°rios de funcionamento  
- Formas de pagamento aceitas  
- Disponibilidade para delivery ou retirada  
- Informa√ß√µes sobre eventos e promo√ß√µes  
- Suporte para clientes com d√∫vidas ou problemas  
- Como enviar curr√≠culo ou saber sobre vagas  
- Contato institucional  

N√£o atenda perguntas sobre:
- Previs√£o do tempo, celebridades, esportes, pol√≠tica, outras empresas ou marcas  
- Not√≠cias, acontecimentos hist√≥ricos ou dicas de fora do universo do Caf√© Flor de Minas  
- Respostas filos√≥ficas, motivacionais ou que n√£o levem a uma a√ß√£o √∫til para o cliente  

Sua miss√£o √© simples: ser o porta-voz virtual do Caf√© Flor de Minas com empatia, aten√ß√£o e carinho.
"""

model = genai.GenerativeModel('gemini-1.5-flash', system_instruction=system_instruction)

app = FastAPI()

origins = ["http://localhost:5173", "http://127.0.0.1:5173"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(auth_controller.router)

class ChatRequest(BaseModel):
    chatId: Optional[str] = None
    prompt: str
    history: List[Dict[str, Any]] = []

@app.options("/chat")
async def chat_options(request: Request):
    return {}

@app.post("/set-ia-status")
async def set_ia_status(
    chatId: str = Body(...),
    iaOn: bool = Body(...),
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] not in ["admin", "funcionario"]:
        raise HTTPException(status_code=403, detail="Acesso negado")
    ia_status[chatId] = iaOn
    return {"status": "ok", "iaOn": iaOn}

@app.get("/get-ia-status")
async def get_ia_status(
    chatId: str,
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] not in ["admin", "funcionario"]:
        raise HTTPException(status_code=403, detail="Acesso negado")
    return {"iaOn": ia_status.get(chatId, True)}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    websocket_connections.add(websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        websocket_connections.remove(websocket)

def notify_clients(message: dict):
    for ws in list(websocket_connections):
        try:
            import asyncio
            asyncio.create_task(ws.send_json(message))
        except Exception:
            websocket_connections.discard(ws)

@app.post("/chat")
async def chat(req: ChatRequest, current_user: dict = Depends(get_current_user)):
    db = SessionLocal()
    chat_id = req.chatId or str(uuid.uuid4())
    prompt = req.prompt

    if not prompt:
        db.close()
        return {"error": "Prompt vazio."}

    # Busca ou cria o chat no banco
    chat = db.query(ChatDB).filter_by(id=chat_id, closed=False).first()
    if not chat:
        chat = ChatDB(
            id=chat_id,
            user_id=None, 
            username=current_user["username"],
            last_message=prompt,
            last_message_time=datetime.utcnow(),
            online=True,
            closed=False
        )
        db.add(chat)
        db.commit()
        notify_clients({"type": "new_chat", "chatId": chat_id})
    else:
        chat.last_message = prompt
        chat.last_message_time = datetime.utcnow()
        chat.online = True
        db.commit()

    user_msg = MessageDB(
        chat_id=chat_id,
        role="user",
        text=prompt
    )
    db.add(user_msg)
    db.commit()
    notify_clients({"type": "new_message", "chatId": chat_id})

    if not ia_status.get(chat_id, True):
        db.close()
        return {"result": "Aguarde, um atendente ir√° responder em instantes.", "chatId": chat_id}

    try:
        response = model.generate_content(prompt)
        result = response.text
        ia_msg = MessageDB(
            chat_id=chat_id,
            role="model",
            text=result
        )
        db.add(ia_msg)
        db.commit()
        notify_clients({"type": "new_message", "chatId": chat_id})
        db.close()
        return {"result": result, "chatId": chat_id}
    except Exception as e:
        db.close()
        raise HTTPException(status_code=500, detail="Erro interno do servidor")

@app.get("/chats")
async def list_chats(current_user: dict = Depends(get_current_user)):
    db = SessionLocal()
    if current_user["role"] in ["admin", "funcionario"]:
        chats = (
            db.query(ChatDB)
            .options(joinedload(ChatDB.messages))
            .filter(ChatDB.closed == False)
            .all()
        )
    else:
        chats = (
            db.query(ChatDB)
            .options(joinedload(ChatDB.messages))
            .filter(ChatDB.username == current_user["username"], ChatDB.closed == False)
            .all()
        )
    result = [
        {
            "chat_id": chat.id,
            "username": chat.username,
            "last_message": chat.last_message,
            "online": chat.online,
        }
        for chat in chats if chat.messages and len(chat.messages) > 0
    ]
    db.close()
    return {"chats": result}

@app.get("/history")
async def get_history(chatId: str, current_user: dict = Depends(get_current_user)):
    db = SessionLocal()
    messages = db.query(MessageDB).filter_by(chat_id=chatId).order_by(MessageDB.timestamp).all()
    history = [
        {"role": msg.role, "parts": [{"text": msg.text}]}
        for msg in messages
    ]
    db.close()
    return {"history": history}

class ManualReplyRequest(BaseModel):
    chatId: str
    message: str

@app.post("/manual-reply")
async def manual_reply(
    req: ManualReplyRequest,
    current_user: dict = Depends(get_current_user)
):
    if current_user["role"] not in ["admin", "funcionario"]:
        raise HTTPException(status_code=403, detail="Acesso negado")
    db = SessionLocal()
    chat_id = req.chatId
    message = req.message

    agent_msg = MessageDB(
        chat_id=chat_id,
        role="agent",
        text=message
    )
    db.add(agent_msg)
    db.commit()
    db.close()

    notify_clients({"type": "new_message", "chatId": chat_id})

    return {"status": "ok"}

class CloseChatRequest(BaseModel):
    chatId: str

@app.post("/close-chat")
async def close_chat(
    req: CloseChatRequest,
    current_user: dict = Depends(get_current_user)
):
    chatId = req.chatId
    db = SessionLocal()
    chat = db.query(ChatDB).filter_by(id=chatId, closed=False).first()
    if not chat:
        db.close()
        raise HTTPException(status_code=404, detail="Chat n√£o encontrado")
    if current_user["role"] not in ["admin", "funcionario"] and chat.username != current_user["username"]:
        db.close()
        raise HTTPException(status_code=403, detail="Acesso negado")
    chat.closed = True
    db.commit()
    db.close()
    notify_clients({"type": "chat_closed", "chatId": chatId})  
    return {"status": "ok"}

def close_inactive_chats():
    db = SessionLocal()
    now = datetime.utcnow()
    timeout = timedelta(minutes=30)
    chats = db.query(ChatDB).filter_by(closed=False).all()
    for chat in chats:
        if chat.last_message_time and now - chat.last_message_time > timeout:
            chat.closed = True
    db.commit()
    db.close()

def schedule_close_inactive_chats():
    while True:
        close_inactive_chats()
        time.sleep(60) 

@app.on_event("startup")
def start_scheduler():
    threading.Thread(target=schedule_close_inactive_chats, daemon=True).start()

class FeedbackRequest(BaseModel):
    chatId: str
    rating: int

@app.post("/feedback")
async def feedback(req: FeedbackRequest, current_user: dict = Depends(get_current_user)):
    db = SessionLocal()
    chat = db.query(ChatDB).filter_by(id=req.chatId).first()
    if not chat:
        db.close()
        raise HTTPException(status_code=404, detail="Chat n√£o encontrado")
    if chat.username != current_user["username"]:
        db.close()
        raise HTTPException(status_code=403, detail="Apenas o dono do chat pode avaliar")
    existing = db.query(FeedbackDB).filter_by(chat_id=req.chatId).first()
    if existing:
        db.close()
        raise HTTPException(status_code=400, detail="J√° existe feedback para este chat")
    feedback = FeedbackDB(chat_id=req.chatId, rating=req.rating)
    db.add(feedback)
    db.commit()
    db.close()
    return {"status": "ok"}

@app.get("/chat-stats")
async def chat_stats(current_user: dict = Depends(get_current_user)):
    db = SessionLocal()
    now = datetime.utcnow()
    last_24h = now - timedelta(hours=24)

    total_open = db.query(ChatDB).filter_by(closed=False).count()
    total_closed_24h = db.query(ChatDB).filter(ChatDB.closed == True, ChatDB.last_message_time >= last_24h).count()
    total_opened_24h = db.query(ChatDB).filter(ChatDB.last_message_time >= last_24h).count()

    db.close()
    return {
        "open": total_open,
        "closed_24h": total_closed_24h,
        "opened_24h": total_opened_24h
    }